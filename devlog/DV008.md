# Devlog 008

***

[Previous](DV007.md)

***

## The Plan

Now that the game is at a point where I can actually start working on *GAME* things instead of *ENGINE* things, I'm starting off with a list of things I want to implement.

* Attack Combos
* Level Editor
* Enemy Attacks
* Audio Engine
* Basic Settings

Of course, each of these tasks require a lot of multiple smaller tasks, but this is the basic guideline that I'm gunning for. Of course, on top of coding these features I'll also be adding art and stuff along the way but I'm not gonna plan that for now until I really have a sense of where the game's headed.

***

## Basic Attack Combos

Instead of planning out how I'm gonna build the combo system, I kind of just jumped right into it and hacked together a simple solution. It is not really elegant but I think it will suffice for the scope of this game. Essentially, I just changed the code in the attack function to check if the hero is dashing to determine whether to execute a combo or not. If *dashing* is true, then the player pressed the button in the middle of a dash which means a combo will execute, in which a *combo1Attack* function will trigger and execute the combo. Here's what the code looks like:

```c++
void Hero::combo1Attack() {
	// stop dashing and perform a combo attack
	dashing = false;
	dashTimer = 0.0f;
	// start attack timer again
	attacking = true;
	attackTimer = HERO::COMBO_1_TIME;
	// update animations
	animState = COMBO1;
	setNextAnimation(faceRight ? IDLE_RIGHT : IDLE_LEFT);
	playAnimation(animState);
	resetAnimationFrame();
}

// part of the new key1Attack function...
void Hero::key1Attack() {
	if (attacking) {
		return;
	}
	if (dashing) {
		std::cout << "HELL YA" << std::endl;
		combo1Attack();
		return;
	}
	// do the other things in the attack function...
}
```

If I want to add more combos, I would simply use different functions and have different if clauses for them. If I do combos within combos, I think I can use an integer to represent which combo is currently executing and then calculate which combo do trigger from there.

***

## Level Editor

With the basic workings of a combo down, I decided to put it off until I have a more solid foundation of the actual game I want to build. With that, I started working on the level editor. First off, I just added basic game structure that I used in my main game to get a game loop up and running with SDL to the level editor. You can see the commit [here](https://github.com/ianw3214/HeavensEdge/commit/4571eaccde5964dae5211ce3889bb1df3da5ae68).  
Then, I proceeded to add a Tile and Map class, which is almost the same as the Game Engine except I took out a lot of functionality from the Map class. I also got rid of the *delta Time* functionality because it wouldn't be needed in a level editor. One unique function I made was a function to initialize a tile map straight from loading a tile sheet. It looks liek this:
```c++
// initialzie a tile map from loading an image
void Map::initTileIndexMap() {
	// calculate the width and height of the input image
	SDL_Surface* tileSheet = IMG_Load(TILE_SHEET_FILE_PATH.c_str());
	int width = tileSheet->w / TILE_WIDTH, height = tileSheet->h / TILE_HEIGHT;
	// loop through all tiles in the input image
	int numTiles = width * height;
	for (int i = 0; i < numTiles; i++) {
		// calculate the x and y coordinate of the tile
		int x = i % width, y = static_cast<int>(i / width);
		Tile * newTile = new Tile(TILE_SHEET_FILE_PATH, TILE_WIDTH, TILE_HEIGHT, x, y);
		indexMap[i] = newTile;
	}
	return;
}
```
One big design decision I'm making right now is putting things into a constants header. Here's what that looks like right now:
```c++
#pragma once
#include <string>

std::string const TILE_SHEET_FILE_PATH = "../assets/tiles.png";
std::string const OUTPUT_FILE_PATH = "../levels/test.txt";
int const TILE_WIDTH = 64;
int const TILE_HEIGHT = 64;
int const BASE_MAP_WIDTH = 10;
int const BASE_MAP_HEIGHT = 10;
```
The reason I'm doing this is so that I can easily write a wrapper to let the user customize these attributes from within the level editor in the future. I don't want to waste time right now figuring out how to interact with windows to get specific files, so it is a good temporary replacement until I decide to learn how to work with windows.

### Moving the Map

A big part of a level editor is being able to drag the map along to edit tiles at different places. To do the dragging functionality, I had to work with the mouse a bit. To achieve that, I first implemented an *offset* system where the editor would render the map based on an offset. Then, when I want to move the map I can simply adjust the offset and the map will render how I want on screen. Here's what the render function for that looks like:
```c++
void render() {
	SDL_FillRect(display, nullptr, SDL_MapRGB(display->format, 0, 0, 0));
	// render the map
	map->render(display, xOffset, yOffset);
	SDL_UpdateWindowSurface(gWindow);
}
```
Then, I have an event handling function that sets the *SPACE* flag and *LMB* flag to when those two buttons are pressed. Furthermore, when the LMB is pressed, it will record the current mouse position as well as the current offset. Finally, if both buttons are pressed then the update function will update the offset to the new mouse position. With all this combined, the map will act like it is being dragged around by the mouse. The event handling is pretty easy so I will just show the Update function:
```c++
void update() {
	map->update();
	if (SPACE && LMB) {
		int mouseX, mouseY;
		SDL_GetMouseState(&mouseX, &mouseY);
		int xMouseDiff = mouseX - xMouseStartPos;
		int yMouseDiff = mouseY - yMouseStartPos;
		xOffset = xOffsetStart + xMouseDiff;
		yOffset = yOffsetStart + yMouseDiff;
	}
}
```
And just like that, we have the basic structure of the level editor.
