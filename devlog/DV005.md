# Devlog 005

***

## Entity Component Systems

So I've been starting to think about how I'm going to implement health and enemies. Naturally, the subject of *Entity Component Systems* comes up. If you don't know what that is, there are a bunch of great resources online that can explain it a lot better than I can.

However, after some good reading I've decided that I won't need to use them. The goal of the game is to have a lot of unique bosses/monsters that share very little logic/mechanics to each other, so using an ECS doesn't make sense because each component would be pretty much unique to an entity, so I might as well just put the code in the entity itself. However, if I find that I'm re-using a lot of code, I might use some mix of ECS in my own code to make things more readable and all that good stuff. In the end, I don't think my game will be large enough that I will have to worry about performance too much, so I'm just rolling with what I think of.

***

## Entity Class Rehaul

So I've been thinking a bit about how I'm going to implement health/attacks and I've decided to do some restructuring in my code. The way I have it set up now, entities will represent pretty much everything in the game. The way I'm going to change it is that **GameObjects** and **Entities** are going to be different classes, where Entity *inherits* from *Gameobjects*. The *GameObject* class will be the base class that represents everything in the game, from the map to players to particle effects to pretty much anything. The *Entity* class will represent *creatures*, basically anything that has health and attacks or something.

Before I jumped into the code, I started with a basic UML diagram. Keep in mind that I am no professional coder, so the UML may be very inconsistent, I'm not sure if it's even UML.

![UML Diagram of Entity class](../UML/Entity.png)

At this point, I'm not worrying about performance because I don't know if I'll get enough content/features in my game to have to worry about performance. If the game calls for it, then I will dive into optimizing things.

***

## Aftermath of Entity class Rehaul

So the actual code didn't really end up looking like my diagram. There are a few main structural things that had to change a lot.

### The sprite and animated Sprite class

Since GameObject and entity are now separated, sprites inherit from *GameObject* instead of *Entity*. The problem this creates, as we will see from my hero class, is that classes that want to inherit from *Entity* can't inherit from AnimatedSprite, or else I'll have to use **Multiple inheritance** and that adds too much complexity for me.

### The Hero class

So since *Hero* inherits from *Entity* now, I can't inherit from *AnimatedSprite* or else I'll have to deal with multiple inheritance, as explained above. My solution is to use *aggregation* / *composition* or whatever that's called. I'm not really good with the terms yet :/ Anyways, I essentially instantiate an *AnimatedSprite* and have a pointer to it in my *Hero* class. That way, whatever I animated sprite attribute I was using before I can just call on the new Animated Sprite object. For a more detailed look into the implementations, I'll link to the commit where I made the changes below.

[The commit log](https://github.com/ianw3214/HeavensEdge/commit/2def9f0d57a78eebea891d375cbb449bdd96b6de)


***

## Virtual Destructor

So it's getting to the point where memory management is getting important. The first step to prevent memory leaks is to add **virtual destructors**. From my understanding, virtual destructors essentially let inherited classes be properly destructed when called from a base memory type. Reading that again, it is not a very explained sentence so I'll just put it in code.
```c++
class Base{

}
class Foo{
    ~Foo(){ std::cout << 'destruct foo'; }
}
Base * foo = new Foo();
// do osme stuff with foo
delete foo;
```
The above code won't execute the destructor of *foo* when it gets destructed, because the *Base* destructor will try to be called since *foo* is of type *Base*. Since there is no destructor for *Base*, the operation counts as an undefined function so the *foo* doesn't get destructed properly and causes a memory leak. When we add a *virtual destructor*, the program knows to look for the method in the subclasses and call the proper destructors. I won't actually show any code because it's quite trivial, but the general formula looks like this:
```c++
virtual ~ClassName();
```
The **~** is just the destructor symbol for those who don't know. We can then implement the function in our .cpp file if we want to do any additional cleanup.

***

## Smart Pointers

Smart pointers are quite crucial in memory management, but after some tinkering I wasn't able to get it to work. Therefore, I'm going to leave this task up to future me, and hopefully it won't be too hard to add after I've put on some more stuff.

Even though I'm not adding it in yet, I'll still try to explain smart pointers a bit. Essentially, a **smart pointer** deallocates the objects that they point to once the object can no longer be referenced. To my knowledge, there are 2 types of smart pointers, the *unique_ptr* and *shared_ptr*. Smart pointers are closely tied to the idea of **Resource Allocation is Initialization**. There are a ton of great articles that can explain RAII probably a lot better than I can, so I'm not really going to bother. In a nutshell, smart pointers can clean up after themselves once they are no longer needed.

[RAII - cppReference](http://en.cppreference.com/w/cpp/language/raii)

***

## Optimization for real

I was trying pretty hard to optimize my check collision algorithm last week but I failed. Somehow looking at it again just gave me the solution so I did it boiiis!! I'll slowly walk you through it.

First, lets recap the problem from before. The *checkCollision* function was running through each tile in the tileMap and checking for collisions against every single tile. It was very inefficient because the player couldn't take up more than 4 spaces of tiles, yet the algorithm was still checking against every single tile. At first glance, the solution is pretty simple: Reduce the amount of tiles that are checked by the algorithm. However, I got stuck last time because I forgot that I was using the index to calculate tile position in checking, so I got confused last time and quit (temporarily). This time, I found out what I was doing wrong and was able to fix it. Yay me!

So, on to the solution. How did I reduce the range? Well I took advantage of a *feature* of c++: dividing and int by and int rounds down if there is a decimal. Therefore, if I take the player x position and y position and divide it with the tile Size, I get the upper left tile that the player is on. Basically, since the player is only as big as a tile, it can only span up to 4 tiles. That means that if I can get the upper left tile, I can get the 3 other tiles as well and therefore I can get the tiles the player span and just check those for collision. So, after I get the upper left tile, I transform the coordinates into an index. For example, if I have an *x position* of 5 and *y position* of 5 and the level was 10 tiles wide, the index would be *5 * 10 + 5* since that would be the index of the tile stored in the collision array. I then calculated the other indices based on that initial index and check against those to determine collision.

Here is my resulting code for the collision function:
```c++
bool Hero::checkCollision(int xpos, int ypos) {
	std::vector<int> checkIndices;			// vector to hold indices of collision map to check
	// get the players left and up most tile box
	int tileX = static_cast<int>(xpos / tileSize);
	int tileY = static_cast<int>(ypos / tileSize);
	// we only have to check 4 boxes because the player spans at most 4 tiles
	// since x and y round down, we know we only have to get the right and bottom tiles
	int targetIndex = tileY * levelWidth + tileX;
	checkIndices.push_back(targetIndex);	// add the current tile always
	// if we aren't at the right most side of the level, add the tile 1 to the right
	if(tileX != levelWidth-1){ checkIndices.push_back(targetIndex + 1); }
	// if we aren't at the bottom, add the bottom 2 tiles
	if ((tileY + 1) * levelWidth < collisionMap.size()) {
		checkIndices.push_back(targetIndex + levelWidth);
		checkIndices.push_back(targetIndex + levelWidth + 1);
	}
	for (unsigned int i = 0; i < checkIndices.size(); i++) {
		int collisionIndex = checkIndices.at(i);
		// for now, check every single tile for a collision
		if (collisionMap.at(collisionIndex) == 1) {	// 1 means it is a collidable tile
			// check the coords of the tile against player position
			int targetX = (collisionIndex % levelWidth) * tileSize;
			int targetY = static_cast<int>(collisionIndex / levelWidth) * tileSize;
			// first check x coordinates
			if (xpos + sprite->getTileWidth() > targetX && xpos < (targetX + tileSize)) {
				// check y coordinates
				if (ypos + sprite->getTileHeight() > targetY && ypos < (targetY + tileSize)) {
					// return true only if both x and y intersect
					return true;
				}
			}
		}
	}
	// return false if no collision happened
	return false;
}
```
Note that even though the function is even larger than before in terms of lines, the efficiency is still improved in most cases because the number of for loops that are run is a lot lower. However, if I for some reason had a level with 4 or even 1 tile, then the changes I made would make the algorithm even slower because the calculations I do beforehand adds a lot more calculations than it does taking out from the for loop. I probably won't be making such small levels though so we're good :)
