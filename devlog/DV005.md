# Devlog 005

***

## Entity Component Systems

So I've been starting to think about how I'm going to implement health and enemies. Naturally, the subject of *Entity Component Systems* comes up. If you don't know what that is, there are a bunch of great resources online that can explain it a lot better than I can.

However, after some good reading I've decided that I won't need to use them. The goal of the game is to have a lot of unique bosses/monsters that share very little logic/mechanics to each other, so using an ECS doesn't make sense because each component would be pretty much unique to an entity, so I might as well just put the code in the entity itself. However, if I find that I'm re-using a lot of code, I might use some mix of ECS in my own code to make things more readable and all that good stuff. In the end, I don't think my game will be large enough that I will have to worry about performance too much, so I'm just rolling with what I think of.

***

## Entity Class Rehaul

So I've been thinking a bit about how I'm going to implement health/attacks and I've decided to do some restructuring in my code. The way I have it set up now, entities will represent pretty much everything in the game. The way I'm going to change it is that **GameObjects** and **Entities** are going to be different classes, where Entity *inherits* from *Gameobjects*. The *GameObject* class will be the base class that represents everything in the game, from the map to players to particle effects to pretty much anything. The *Entity* class will represent *creatures*, basically anything that has health and attacks or something.

Before I jumped into the code, I started with a basic UML diagram. Keep in mind that I am no professional coder, so the UML may be very inconsistent, I'm not sure if it's even UML.

![UML Diagram of Entity class](../UML/Entity.png)

At this point, I'm not worrying about performance because I don't know if I'll get enough content/features in my game to have to worry about performance. If the game calls for it, then I will dive into optimizing things.

***

## Aftermath of Entity class Rehaul

So the actual code didn't really end up looking like my diagram. There are a few main structural things that had to change a lot.

### The sprite and animated Sprite class

Since GameObject and entity are now separated, sprites inherit from *GameObject* instead of *Entity*. The problem this creates, as we will see from my hero class, is that classes that want to inherit from *Entity* can't inherit from AnimatedSprite, or else I'll have to use **Multiple inheritance** and that adds too much complexity for me.

### The Hero class

<<<<<<< HEAD
So since *Hero* inherits from *Entity* now, I can't inherit from *AnimatedSprite* or else I'll have to deal with multiple inheritance, as explained above. My solution is to use *aggregation* / *composition* or whatever that's called. I'm not really good with the terms yet :/ Anyways, I essentially instantiate an *AnimatedSprite* and have a pointer to it in my *Hero* class. That way, whatever I animated sprite attribute I was using before I can just call on the new Animated Sprite object. For a more detailed look into the implementations, I'll link to the commit where I made the changes below.

[The commit log](https://github.com/ianw3214/HeavensEdge/commit/2def9f0d57a78eebea891d375cbb449bdd96b6de)


***

## Virtual Destructor

So it's getting to the point where memory management is getting important. The first step to prevent memory leaks is to add **virtual destructors**. From my understanding, virtual destructors essentially let inherited classes be properly destructed when called from a base memory type. Reading that again, it is not a very explained sentence so I'll just put it in code.
```c++
class Base{

}
class Foo{
    ~Foo(){ std::cout << 'destruct foo'; }
}
Base * foo = new Foo();
// do osme stuff with foo
delete foo;
```
The above code won't execute the destructor of *foo* when it gets destructed, because the *Base* destructor will try to be called since *foo* is of type *Base*. Since there is no destructor for *Base*, the operation counts as an undefined function so the *foo* doesn't get destructed properly and causes a memory leak. When we add a *virtual destructor*, the program knows to look for the method in the subclasses and call the proper destructors. I won't actually show any code because it's quite trivial, but the general formula looks like this:
```c++
virtual ~ClassName();
```
The **~** is just the destructor symbol for those who don't know. We can then implement the function in our .cpp file if we want to do any additional cleanup.

***

## Smart Pointers

Smart pointers are quite crucial in memory management, but after some tinkering I wasn't able to get it to work. Therefore, I'm going to leave this task up to future me, and hopefully it won't be too hard to add after I've put on some more stuff.

Even though I'm not adding it in yet, I'll still try to explain smart pointers a bit. Essentially, a **smart pointer** deallocates the objects that they point to once the object can no longer be referenced. To my knowledge, there are 2 types of smart pointers, the *unique_ptr* and *shared_ptr*. Smart pointers are closely tied to the idea of **Resource Allocation is Initialization**. There are a ton of great articles that can explain RAII probably a lot better than I can, so I'm not really going to bother. In a nutshell, smart pointers can clean up after themselves once they are no longer needed.
