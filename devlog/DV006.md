# Devlog 006


***

## Basic menu

To start with, I implemented a bare bones menu. In fact, it is so basic that it isn't even a menu, it is more of a transition state. I just put it in first so that I know the state transitions work. All it does right now is show a black screen and go to the level when the player presses the space bar. Let's see how I made this magical thing! First of all, I added 2 files, *menu.cc* and *menu.h*. For now, the menu class doesn't even inherit all the base functions yet, I only have the *handleEvents* function implemented to detect a key press.
```c++
// menu.h
class Menu : public State{
public:
	Menu();
	~Menu() {};
	void handleEvents(SDL_Event);
private:
	void handleKeyPress(SDL_Keycode);
};
```
And the implementation in the source file is quite trivial as well:
```c++
// menu.cc
Menu::Menu() {
}
void Menu::handleEvents(SDL_Event event) {
	if (event.type == SDL_KEYDOWN) {
		handleKeyPress(event.key.keysym.sym);
	}
}
void Menu::handleKeyPress(SDL_Keycode key) {
	if (key == SDLK_SPACE) {
		// go to the level
		nextState = new Level("levels/test.txt");
		quit = true;
	}
}
```
After putting these two files into the project, all I had to do was change *main.cpp* to run a Menu instead of a Level and voila! Super bare bones menu.

***

## Menu Select Function

What's a menu without the ability to select different options? Let's *'add'* some options then. To do this, I am using a linked list that holds data about the menu item and pointers to the next and previous menu items. Unlike a normal linked list, my initial pointer doesn't go to the first node in the list and instead it points to whatever node is currently selected by the player. By doing so, I make sure I only have 1 item selected and that the item is always valid by putting *nullptr* checks. If the user presses a key, I simply navigate to the next/previous pointer and if it doesn't exist then the menuItem doesn't change. To implement this, I first make a struct representing the menu Nodes in the linked list.

```c++
struct menuItem{
	menuItem * previous;
	menuItem * next;
	int ID;
	menuItem(menuItem* a, menuItem* b, int c) : previous(a), next(b), ID(c) {};
};
```
Then, I initialize some testing menuItems in the constructor of the menu.
```c++
// initialize a test menu
currentMenuItem = new menuItem(nullptr, nullptr, 1);
menuItem * item2 = new menuItem(currentMenuItem, nullptr, 2);
menuItem * item3 = new menuItem(item2, nullptr, 3);
item2->next = item3;
currentMenuItem->next = item2;
```
Now, when the player presses the arrow keys, the linked list will navigate to the corresponding menu Item. I also added a **select** function that is triggered when the user presses the select key, and it updates the menu depending on what the current node is pointing to. Right now, the game continues if the node is the first item and does nothing otherwise.
```c++
// the select function
void Menu::select() {
	if (currentMenuItem->ID == 1) {
		nextState = new Level("levels/test.txt");
		quit = true;
	}
}
```
