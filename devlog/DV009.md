# Devlog 009

***

[Previous](DV008.md)

***

## The Plan

So last week I set up a lot of the infrastructure to actually make the content of the game, specifically the level editor. I will hopefully start making a level; I want to finish at least one basic level with finished sprites/music. Before that though, there are still a few systems I want to set up first, namely NPCs. Once I finish designing the systems for NPCs, then I can really design a level that looks real. Here's a list of things I want to achieve this week.

* NPC system
* NPC loading from file
* enemy loading from file
* art/music for first level

As you can see, not too much planned for this week but each task is a bit heavier than usual so it will probably work out.

***

## Implementing a basic NPC

So I have now implemented a basic NPC that will speak with the console! That's a start I guess. Also I have to stop starting these paragraphs with the word *so*. Anyways, the NPC system is quite simple, I don't plan on making it any more intricate because I don't want my game to be too revolved around the story/plot. I simply wanted to have NPCs to make the world seem more lively. I'm not going to put up the NPC code, it is basically built on top of the creature class but it has an extra attribute storing a vector of strings. The *kind of harder but not really* part was getting the interaction to work. Right now, the player just finds the first NPC in the vector to interact with but soon I will have to add range and distance comparing to make things seem more natural. Anyways, here's the code for handling the dialogue:
```c++
void Hero::handleDialogue() {
	if (inDialogue) {
		if (currentDialogue.size() <= dialogueIndex) {
			inDialogue = false;
			dialogueIndex = 0;
			currentDialogue = {};
		} else {
			std::cout << currentDialogue.at(dialogueIndex) << std::endl;
			dialogueIndex++;
		}
	} else {
		for (unsigned int i = 0; i < entityList->size(); i++) {
			if (entityList->at(i)->getType() == 4) {
				NPC * temp = dynamic_cast<NPC*>(entityList->at(i));
				currentDialogue = temp->getDialogue();
				break;
			}
		}
		// if the vector is empty, simply reset and exit
		if (currentDialogue.size() == 0) { return; }
		// otherwise, play the first line of the dialogue
		else if (currentDialogue.size() == 1) {
			std::cout << currentDialogue.at(0) << std::endl;
			currentDialogue = {};
		} else {
			inDialogue = true;
			std::cout << currentDialogue.at(0) << std::endl;
			dialogueIndex++;
		}
	}
}
```
So on the first interaction, the player will look for an NPC to get the dialogue of and print the first line of the dialogue if it exists. Then, on subsequent calls, the player will print the rest of the vector until there is nothing else to print, and then everything resets. Of course, This will eventually be words on the screen but for now, It is just console text being printed.

One more thing that I have to keep in mind is that I have to stop movement later while the player is in dialogue. It should be easy to implement but It's still something I have to do anyways.

***

## Circular Collisions

One thing I wanted to add was circles, but I could never justify adding them until now. Using squares to find if NPCs were within range just felt unnatural, so I used a circle to represent the range at which players could interact with an NPC. The new struct for Circle is quite easy, it is just 3 variables: *x*, *y*, and *r*, which stands for radius. The collision code isn't too hard either, it looks for the closest point of the rectangle to the circle and compares the distance to the radius and if it is too long then the objects aren't colliding. I didn't think of this myself, I found it on a [stackoverflow post](https://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection). Anyways, here's the collision code:
```c++
bool collisionCircleRect(const Circle& circle, const Rectangle& rect) {
	// find collision by finding shortest point and then comparing distance against radius
	int closestX = clamp(circle.x, rect.x, rect.x + rect.w);
	int closestY = clamp(circle.y, rect.y, rect.y + rect.h);
	int distanceX = circle.x - closestX;
	int distanceY = circle.y - closestY;
	float distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);
	// if the distance is longer than the radius, the function will return false
	return distanceSquared < (circle.r * circle.r);
}
int clamp(int val, int min, int max) {
	if (val > max) return max;
	if (val < min) return min;
	return val;
}
```
The **clamp** function simply limits the *val* parameter to the range created by *[min..max]*. With this, I could update the dialogue code in the hero class to use the new collision code, here's the NPC searching function now:
```c++
void Hero::findNPCforDialogue() {
	for (unsigned int i = 0; i < entityList->size(); i++) {
		if (entityList->at(i)->getType() == 4) {
			NPC * temp = dynamic_cast<NPC*>(entityList->at(i));
			Circle range(x + 32, y + 32, 96);
			if (isColliding(range, *(temp->getCollisionBox()))) {
				currentDialogue = temp->getDialogue();
				break;
			}
		}
	}
	// do stuff...
}
```
Now I have to somehow find the closest NPC instead of just finding the first one in the vector. I have a pretty good idea of how I'm going to do that so I'll probably get that done soon.

***

## Nearest NPC

So with the current algorithm, the function just looks for the first NPC in the vector that is in range of the player. However, what we want is to look for the *nearest* NPC to the player. To do that, I calculate the distance from each NPC to the player and instead of breaking the for loop when we find an NPC, we compare the distance to the current minimum and if it is smaller then we set said NPC to be the new minimum. After the for loop ends, we then have the NPC with the smallest distance to the player. Here's what the function looks like now:
```c++
void Hero::findNPCforDialogue() {
	// variables for keeping track of the current nearest NPC
	float minDistance = -1.0;
	NPC * minNPC = nullptr;
	// loop through the entity list and look for the nearest NPC
	for (unsigned int i = 0; i < entityList->size(); i++) {
		if (entityList->at(i)->getType() == 4) {
			NPC * thisNPC = dynamic_cast<NPC*>(entityList->at(i));
			// make a circle for setting up the range
			Circle range(x + 32, y + 32, 96);
			if (isColliding(range, *(thisNPC->getCollisionBox()))) {
				// get the distance and compare it to the current smallest distance
				int xDistance = std::abs(thisNPC->getX() - x);
				int yDistance = std::abs(thisNPC->getY() - y);
				float distance = std::sqrt(xDistance * xDistance + yDistance * yDistance);
				// if the distance is smaller or if it is the first distance, set it to the NPC
				if (distance < minDistance || minDistance < 0.0f) {
					minDistance = distance;
					minNPC = thisNPC;
				}
			}
		}
	}
	// set up dialogue and stuff
}
```
Now that the NPC system is in place, I can start working on loading NPCs from files and including the NPC data in the map files as well.

## NPC loading from file

For now, I'm adding all the map data to the map data file so things can get done a bit faster. In the future, I want to put IDs onto NPCs and enemies so that I can just store IDs in a map data file and then load the actual entities from their corresponding IDs in the file. Anyways, I finished NPC loading in the map class, the actual structure in the file looks like:  
*x coord # y coord # asset path # dialogue 1 # dialogue 2 # ...*  
And here is what the actual loading function looks like:
```c++
void Map::lineToNPCData(std::string line) {
	std::string token = "";
	int counter = 0;
	// variables to hold the NPC data
	NPC * thisNPC = nullptr;
	int x, y;
	std::vector<std::string> dialogue;
	std::string path;
	for (char const & c : line) {
		if (c == '#') {
			if (counter == 0) {
				x = std::stoi(token, nullptr);
				x *= 64;
			}
			if (counter == 1) {
				y = std::stoi(token, nullptr);
				y *= 64;
			}
			if (counter == 2) {	path = token;}
			if (counter >= 3) {	dialogue.push_back(token); }
			// reset the token and increment the counter
			token = "";
			counter++;
		}
		else { token += c;	}
	}
	// if the counter >= 3, then we missed one last token
	if (counter >= 3) dialogue.push_back(token);
	thisNPC = new NPC(x, y, dialogue, path);
	NPCs.push_back(thisNPC);
	return;
}*
```
I'm not going to show what I changed in the actual reading from the file because I want to give that an overhaul soon. Right now, it depends heavily on the order the if statements are read in and it just seems too unstable for me.

With NPC loading done, I implemented NPC loading soon after. It is really similar to NPC loading, but instead of having dialogue right there I load enemies depending on an ID. One thing I might change is use the *factory pattern* to make my enemies instead of IDs, because right now I'm including all my enemy code into my Map class and that just seems awfully bloated. Anyways, if you are interested in how I implemented enemy loading then [here is the link](https://github.com/ianw3214/HeavensEdge/commit/cccf30148c4049c30dbd6ae3c4cfe1320c01d382).
